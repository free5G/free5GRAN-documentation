<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>free5GRAN: Samples extraction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">free5GRAN
   &#160;<span id="projectnumber">V1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_mardown_files__documentation_samples_extraction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Samples extraction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Once synchronized, receiver has to extract physical channels samples from received time domain signal. This is done by removing Cyclic Prefixes (CP), performing FFT (for recovering RE grid) and by finally de-mapping channels to extract samples from RE grid. Physical channels extraction differs depending on the studied channel:</p>
<h2>CP removal</h2>
<p>CP removal is done in <code>FFT</code> implementation, while extracting time-domain signal (file <code>lib/phy/libphy.cpp</code> line <code>568</code>): </p><div class="fragment"><div class="line">for (int i = 0; i &lt; fft_size; i++){</div><div class="line">    fft_in[i][0] = real(time_domain_signal[i + offset + cum_sum_symb[symb_index] + cp_lengths[symb_index]]);</div><div class="line">    fft_in[i][1] = imag(time_domain_signal[i + offset + cum_sum_symb[symb_index] + cp_lengths[symb_index]]);</div><div class="line">}</div></div><!-- fragment --><p> Adding <code>cp_lengths[symb_index]</code> while extracting time domain signal deletes the CP (original symbol length is <code>fft_size + cp_lengths[symb_index]</code> and we only take the <code>fft_size</code>-th last elements).</p>
<h2>FFT</h2>
<p>FFT function is called from implementation part in <code><a class="el" href="phy_8cpp.html">src/phy/phy.cpp</a></code>, for example: </p><div class="fragment"><div class="line">{c++}</div><div class="line"> free5GRAN::phy::signal_processing::fft(ssb_signal, ssb_symbols,fft_size,cp_lengths_pbch,&amp;cum_sum_fft[0],free5GRAN::NUM_SYMBOLS_SSB - 1,free5GRAN::NUM_SC_SSB,1,0);</div></div><!-- fragment --><h2>Channel demapping</h2>
<p>Channel demapping is done using <code>channel_demapper</code> function implemented in library and called from <code><a class="el" href="phy_8cpp.html">src/phy/phy.cpp</a></code>.</p>
<h3>PBCH</h3>
<p>Receiver deduces PBCH symbols position from PSS position. PBCH and PBCH DMRS samples extraction depends on cell PCI (Further details can be found in TS 38.211 Section 7.3.3.3 and 7.4.1.4.2.</p>
<p>We first compute different channel indexes in RE grid: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::physical_channel::compute_pbch_indexes(ref, pci);</div></div><!-- fragment --><p>And then perform channel demapping: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::signal_processing::channel_demapper(ssb_symbols, ref, output_channels, channel_indexes, 3, free5GRAN::NUM_SYMBOL_PBCH_SSB, free5GRAN::NUM_SC_SSB);</div></div><!-- fragment --><h3>PDCCH</h3>
<p>Receiver performs blind search as PDCCH time and frequency position are not known. MIB data, decoded from PBCH, gives information about CORESET0, which is a set of frequency and time positions (detailed in TS 38.213 Section 13) where PDCCH could be located. Receiver has to search over all the possible positions. Each candidate can be validated by CRC computation. For each candidate, receiver computes PDCCH and PDCCH DMRS positions, as detailed in TS 38.211 Section 7.3.2.5 and 7.4.1.3.2. Before extracting PDCCH, CCE-to-REG mapping has to be computed: </p><div class="fragment"><div class="line">{c++}</div><div class="line">int height_reg_rb = free5GRAN::NUMBER_REG_PER_CCE / pdcch_ss_mon_occ.n_symb_coreset;</div><div class="line">int R = 2;</div><div class="line">int C = pdcch_ss_mon_occ.n_rb_coreset / (height_reg_rb * R);</div><div class="line">int j;</div><div class="line">int reg_index[C * R];</div><div class="line">for (int c = 0; c &lt; C; c ++){</div><div class="line"> for (int r = 0; r &lt; R; r ++){</div><div class="line">     j = c * R + r;</div><div class="line">     reg_index[j] = (r * C + c + this-&gt;pci) % (pdcch_ss_mon_occ.n_rb_coreset/height_reg_rb);</div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --><p>First, receiver loops over different monitoring slots: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (int monitoring_slot = 0; monitoring_slot &lt; 2; monitoring_slot ++){</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> For the corresponding slot, we compute the DMRS sequence: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (int symb = 0; symb &lt; pdcch_ss_mon_occ.n_symb_coreset; symb ++){</div><div class="line">    free5GRAN::utils::sequence_generator::generate_pdcch_dmrs_sequence(pci, pdcch_ss_mon_occ.n0 + monitoring_slot, pdcch_ss_mon_occ.first_symb_index + symb, global_sequence[symb], pdcch_ss_mon_occ.n_rb_coreset * 3);</div><div class="line">}</div></div><!-- fragment --><p> Then, loop over possibles aggregation levels: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (int i = 2; i &lt; 5; i ++){</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> and over candidates: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (int p = 0; p &lt; num_candidates; p ++){</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Compute channels indexes in RE grid: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::physical_channel::compute_pdcch_indexes(ref, pdcch_ss_mon_occ, agg_level, reg_bundles, height_reg_rb);</div></div><!-- fragment --><p> And perform channel de-mapping: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::signal_processing::channel_demapper(coreset_0_samples, ref, output_channels, channel_indexes, 2, pdcch_ss_mon_occ.n_symb_coreset, 12 * pdcch_ss_mon_occ.n_rb_coreset);</div></div><!-- fragment --><p>Finally, perform DMRS sequence CCE-to-REG interleaving: </p><div class="fragment"><div class="line">{c++}</div><div class="line">for (int k = 0 ; k &lt; agg_level; k ++){</div><div class="line">    for (int reg = 0; reg &lt; free5GRAN::NUMBER_REG_PER_CCE; reg ++){</div><div class="line">        dmrs_sequence[((agg_level * free5GRAN::NUMBER_REG_PER_CCE * 3) / pdcch_ss_mon_occ.n_symb_coreset) * (reg%pdcch_ss_mon_occ.n_symb_coreset) +  k * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3] = global_sequence[reg%pdcch_ss_mon_occ.n_symb_coreset][reg_bundles[k] * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3];</div><div class="line">        dmrs_sequence[((agg_level * free5GRAN::NUMBER_REG_PER_CCE * 3) / pdcch_ss_mon_occ.n_symb_coreset) * (reg%pdcch_ss_mon_occ.n_symb_coreset) +  k * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3 + 1] = global_sequence[reg%pdcch_ss_mon_occ.n_symb_coreset][reg_bundles[k] * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3 + 1];</div><div class="line">        dmrs_sequence[((agg_level * free5GRAN::NUMBER_REG_PER_CCE * 3) / pdcch_ss_mon_occ.n_symb_coreset) * (reg%pdcch_ss_mon_occ.n_symb_coreset) +  k * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3 + 2] = global_sequence[reg%pdcch_ss_mon_occ.n_symb_coreset][reg_bundles[k] * height_reg_rb * 3 + (reg/pdcch_ss_mon_occ.n_symb_coreset) * 3 + 2];</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, if CRC is validated, PDCCH is found and nested loops stop.</p>
<h3>PDSCH</h3>
<p>Receiver extracts PDSCH based on DCI, decoded from PDCCH. It gives time and frequency position of PDSCH (as explained in TS 38.214 Section 5.1). PDSCH DMRS positions vary depending on PDSCH resources allocation.</p>
<p>First, receiver computes channels indexes in RE grid: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::physical_channel::compute_pdsch_indexes(ref, dmrs_symbol_array, L, lrb);</div></div><!-- fragment --><p> And then performs channel de-mapping: </p><div class="fragment"><div class="line">{c++}</div><div class="line">free5GRAN::phy::signal_processing::channel_demapper(pdsch_samples, ref, output_channels, channel_indexes, 2, L, 12 * lrb);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
